<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on </title>
    <link>https://feilengcui008.github.io/categories/go/</link>
    <description>Recent content in Go on </description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 24 Jul 2017 09:48:05 +0800</lastBuildDate>
    <atom:link href="https://feilengcui008.github.io/categories/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fuzz go struct using reflection</title>
      <link>https://feilengcui008.github.io/post/fuzz-go-struct-using-reflection/</link>
      <pubDate>Mon, 24 Jul 2017 09:48:05 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/fuzz-go-struct-using-reflection/</guid>
      <description>&lt;p&gt;有时为了测试接口，需要伪造一些随机的请求数据，所以基于Go反射写了一个&lt;a href=&#34;https://github.com/feilengcui008/pieces/blob/master/go/lib/fuzz/fuzz.go&#34;&gt;fuzz&lt;/a&gt;小工具来自动填充请求结构体，基本上支持大部分的Go类型：integer、float、bool、string、slice、map、struct、pointer，而且支持非导出类型(包括非导出的nil value)。实现的思路比较简单，只是有两个地方使用的小trick值得提一提，对深入理解Go的反射有些帮助。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.unexported字段&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Go的反射不允许对struct中未导出的字段设置值，即是unsettable的，所以无法直接使用Set或SetXXX的方法。这里的技巧在于reflect.NewAt，这个函数可以在当前reflect.Value指向的数据的同一内存地址重新构造相同类型的值，并返回指针的reflect.Value，而其Elem是settable的，所以可以通过这种方式绕过限制，具体可参考&lt;a href=&#34;https://github.com/feilengcui008/pieces/blob/master/go/lib/fuzz/fuzz.go#L77&#34;&gt;这行代码&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2.unexported且nil的字段&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;除了需要unexported字段相同的处理方式，由于nil字段反射后是nil value，其Elem是zero value，而zero value是unsettable和unaddressable的，因此需要新建一个Elem类型的值(reflect.New)并赋给nil value，此后其Elem就可以使用Set/SetXXX正常赋值了，具体可参考&lt;a href=&#34;https://github.com/feilengcui008/pieces/blob/master/go/lib/fuzz/fuzz.go#L67&#34;&gt;这几行代码&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go调度详解</title>
      <link>https://feilengcui008.github.io/post/go%E8%B0%83%E5%BA%A6%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Tue, 09 May 2017 19:40:07 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/go%E8%B0%83%E5%BA%A6%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;1-基本单元&#34;&gt;1. 基本单元&lt;/h2&gt;&#xA;&lt;p&gt;Go调度相关的四个基本单元是g、m、p、schedt。g是协程任务信息单元，m实际执行体，p是本地资源池和g任务池，schedt是全局资源池和g任务池。这里的m对应一个os线程，所以整个执行逻辑简单来说就是&amp;quot;某个os线程m不断尝试拿资源p并找任务g执行，没有可执行g则睡眠，等待唤醒并重复此过程&amp;quot;，这个执行逻辑加上sysmon系统线程的定时抢占逻辑实际上就是整个宏观的调度逻辑了(其中穿插了很多唤醒m、system goroutine等等复杂的细节)，而找协程任务g的过程占据了其中大部分。g的主要来源有本地队列、全局队列、其他p的本地队列、poller(net和file)，以及一些system goroutine比如timerproc、bgsweeper、gcMarkWorker、runfinq、forcegchelper等。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-调度的整体流程&#34;&gt;2. 调度的整体流程&lt;/h2&gt;&#xA;&lt;p&gt;(1) 关于g0栈和g栈&lt;/p&gt;&#xA;&lt;p&gt;由于m是实际执行体，m的整个代码逻辑基本上就是整个调度逻辑。类似于Linux的内核栈和用户栈，Go的m也有两类栈：一类是系统栈(或者叫调度栈)，主要用于运行runtime的程序逻辑；另一类是g栈，用于运行g的程序逻辑。每个m在创建时会分配一个默认的g叫g0，g0不执行任何代码逻辑，只是用来存放m的调度栈等信息。当要执行Go runtime的一些逻辑比如创建g、新建m等，都会首先切换到g0栈然后执行，而执行g任务时，会切换到g的栈上。在调度栈和g栈上不断切换使整个调度过程复杂了不少。&lt;/p&gt;&#xA;&lt;p&gt;(2) 关于m的spinning自旋&lt;/p&gt;&#xA;&lt;p&gt;在Go的调度中，m一旦被创建则不会退出。在syscall、cgocall、lockOSThread时，为了防止阻塞其他g的执行，Go会新建或者唤醒m(os线程)执行其他的g，所以可能导致m的增加。如何保证m数量不会太多，同时有足够的线程使p(cpu)不会空闲？主要的手段是通过多路复用和m的spinning。多路复用解决网络和文件io时的阻塞(与net poll类似，Go1.8.1的代码中为os.File加了poll接口)，避免每次读写的系统调用消耗线程。而m的spinning的作用是尽量保证始终有m处于spinning寻找g(并不是执行g，充分利用多cpu)的同时，不会有太多m同时处于spinning(浪费cpu)。不同于一般意义的自旋，m处于自旋是指m的本地队列、全局队列、poller都没有g可运行时，m进入自旋并尝试从其他p偷取(steal)g，每当一个spinning的m获取到g后，会退出spinning并尝试唤醒新的m去spinning。所以，一旦总的spinning的m数量大于0时，就不用唤醒新的m了去spinning浪费cpu了。&lt;/p&gt;&#xA;&lt;p&gt;(3) 整个调度的流程图&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;schedule&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://feilengcui008.github.io/images/schedule.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;findrunnable&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://feilengcui008.github.io/images/findrunnable.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;3-m的视角看调度&#34;&gt;3. m的视角看调度&lt;/h2&gt;&#xA;&lt;p&gt;(1) Go中的m大概可分为以下几种&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;系统线程，比如sysmon，其运行不需要p&lt;/li&gt;&#xA;&lt;li&gt;lockedm，与某个g绑定，未拿到对应的lockedg时睡眠，等待被唤醒，无法被调度&lt;/li&gt;&#xA;&lt;li&gt;陷入syscall的m，执行系统调用中，返回时进入调度逻辑&lt;/li&gt;&#xA;&lt;li&gt;cgo的m，cgo的调用实际上使用了lockedm和syscall&lt;/li&gt;&#xA;&lt;li&gt;正在执行goroutine的m&lt;/li&gt;&#xA;&lt;li&gt;正在执行调度逻辑的m&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;(2) 什么时候可能需要新建或者唤醒m&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有新的可运行g或者拿到可运行的g&#xA;&lt;ul&gt;&#xA;&lt;li&gt;goready，将g入队列&lt;/li&gt;&#xA;&lt;li&gt;newproc，新建g并入队列&lt;/li&gt;&#xA;&lt;li&gt;m从schedule拿到g，自身退出spinning&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;有p资源被释放handoff(p)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;(3) m何时交出资源p，并进入睡眠&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;lockedm主动交出p&lt;/li&gt;&#xA;&lt;li&gt;处于syscall中，并被sysmon抢占(超过10ms)交出p&lt;/li&gt;&#xA;&lt;li&gt;cgocall被sysmon抢占交出p，或由于lockedm主动交出p&lt;/li&gt;&#xA;&lt;li&gt;findrunnable没找到可运行的g，主动交出p，进入睡眠&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;4-g的视角看调度&#34;&gt;4. g的视角看调度&lt;/h2&gt;&#xA;&lt;p&gt;(1) 与goroutine相关的调度逻辑&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;go(runtime.newproc)产生新的g，放到本地队列或全局队列&lt;/li&gt;&#xA;&lt;li&gt;gopark，g置为waiting状态，等待显示goready唤醒，在poller中用得较多&lt;/li&gt;&#xA;&lt;li&gt;goready，g置为runnable状态，放入全局队列&lt;/li&gt;&#xA;&lt;li&gt;gosched，g显示调用runtime.Gosched或被抢占，置为runnable状态，放入全局队列&lt;/li&gt;&#xA;&lt;li&gt;goexit，g执行完退出，g所属m切换到g0栈，重新进入schedule&lt;/li&gt;&#xA;&lt;li&gt;g陷入syscall&#xA;&lt;ul&gt;&#xA;&lt;li&gt;net io和部分file io，没有事件则gopark&lt;/li&gt;&#xA;&lt;li&gt;普通的阻塞系统调用，返回时m重新进入schedule&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;g陷入cgocall&#xA;&lt;ul&gt;&#xA;&lt;li&gt;lockedm加上syscall的处理逻辑&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;g执行超过10ms被sysmon抢占&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Go接口详解</title>
      <link>https://feilengcui008.github.io/post/go%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Sun, 30 Apr 2017 14:45:23 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/go%E6%8E%A5%E5%8F%A3%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;Go接口的设计和实现是Go整个类型系统的一大特点。接口嵌入和组合、duck typing等实现了优雅的代码复用、解耦、模块化的特性，而且接口是方法动态分派、反射的实现基础(当然更基础的是编译为运行时提供的类型信息)。理解了接口的实现之后，就不难理解&amp;quot;著名&amp;quot;的nil返回值问题以及反射、type switch、type assertion等原理。本文主要基于Go1.8.1的源码介绍接口的内部实现及其使用相关的问题。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-接口的实现&#34;&gt;1. 接口的实现&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;下面是接口在runtime中的实现，注意其中包含了接口本身和实际数据类型的类型信息:&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// src/runtime/runtime2.go&#xA;type iface struct {&#xA;  // 包含接口的静态类型信息、数据的动态类型信息、函数表&#xA;  tab  *itab&#xA;  // 指向具体数据的内存地址比如slice、map等，或者在接口&#xA;  // 转换时直接存放小数据(一个指针的长度)&#xA;  data unsafe.Pointer&#xA;}&#xA;type itab struct {&#xA;  // 接口的类型信息&#xA;  inter  *interfacetype&#xA;  // 具体数据的类型信息&#xA;  _type  *_type&#xA;  link   *itab&#xA;  hash   uint32&#xA;  bad    bool&#xA;  inhash bool&#xA;  unused [2]byte&#xA;  // 函数地址表，这里放置和接口方法对应的具体数据类型的方法地址&#xA;  // 实现接口调用方法的动态分派，一般在给接口赋值发生转换时候会&#xA;  // 更新此表，或者从直接拿缓存的itab&#xA;  fun    [1]uintptr // variable sized&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;另外，需要注意与接口相关的两点优化，会影响到反射等的实现:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;(1) 空接口(interface{})的itab优化。当将某个类型的值赋给空接口时，由于空接口没有方法，所以空接口的tab会直接指向数据的具体类型。在Go的reflect包中，&lt;code&gt;reflect.TypeOf&lt;/code&gt;和&lt;code&gt;reflect.ValueOf&lt;/code&gt;的参数都是空接口，因此所有参数都会先转换为空接口类型。这样，反射就实现了对所有参数类型获取实际数据类型的统一。这在后面反射的基本实现中会分析到。&lt;/li&gt;&#xA;&lt;li&gt;(2) 发生接口转换时data字段相关的优化。当被转换为接口的数据的类型长度不超过一个指针的长度时(比如pointer、map、func、chan、[1]int等类型)，接口转换时会将数据直接拷贝存放到接口的data字段中(DirectIface)，而不再额外分配内存并拷贝。另外，从go1.8+的源码来看除了DirectIface的优化以外，还对长度较小(不超过64字节，未初始化数据内存的array，空字符串等)的零值做了优化，也不会重新分配内存，而是直接指向一个包级全局数组变量zeroVal的首地址。注意第2点优化发生在接口转换时生成的临时接口上，而不是被赋值的接口左值上。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;再者，在Go中只有值传递，与具体的类型实现无关，但是某些类型具有引用的属性。典型的9种非基础类型中:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;array传递会拷贝整块数据内存，传递长度为len(arr) * Sizeof(elem)&lt;/li&gt;&#xA;&lt;li&gt;string、slice、interface传递的是其runtime的实现，所以长度是固定的，分别为16、24、16字节(amd64)&lt;/li&gt;&#xA;&lt;li&gt;map、func、chan、pointer传递的是指针，所以长度固定为8字节(amd64)&lt;/li&gt;&#xA;&lt;li&gt;struct传递的是所有字段的内存拷贝，所以长度是所有字段的长度和&lt;/li&gt;&#xA;&lt;li&gt;详细的测试可以参考&lt;a href=&#34;https://github.com/feilengcui008/pieces/blob/master/go/basics/pass_by_value_main.go&#34;&gt;这段程序&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-runtime中接口的转换操作&#34;&gt;2. runtime中接口的转换操作&lt;/h2&gt;&#xA;&lt;p&gt;接口相关的操作主要在于对其内部字段itab的操作，因为接口转换最重要的是类型信息。这里简单分析几个runtime中相关的函数。主要实现在&lt;code&gt;src/runtime/iface.go&lt;/code&gt;中。值得注意的是，接口的类型转换在编译期会生成一个函数调用的语法树节点(OCALL)，调用runtime提供的相应接口转换函数完成接口的类型设置，所以接口的转换是在运行时发生的，其具体类型的方法地址表也是在运行时填写的，这一点和C++的虚函数表不太一样。另外，由于在运行时转换会产生开销，所以对转换的itab做了缓存。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的自举</title>
      <link>https://feilengcui008.github.io/post/go%E7%9A%84%E8%87%AA%E4%B8%BE/</link>
      <pubDate>Thu, 27 Apr 2017 15:37:35 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/go%E7%9A%84%E8%87%AA%E4%B8%BE/</guid>
      <description>&lt;p&gt;Go从1.5开始就基本全部由.go和.s文件写成了，.c文件被全部重写。了解Go语言的自举是很有意思的事情，能帮助理解Go的编译链接流程、Go的标准库和二进制工具等。本文基于go1.8的源码分析了编译时的自举流程。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-基本流程&#34;&gt;1. 基本流程&lt;/h2&gt;&#xA;&lt;p&gt;Go的编译自举流程分为以下几步(假设这里老版本的Go为go_old):&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;go_old -&amp;gt; dist: 用老版本的Go编译出新代码的dist工具&lt;/li&gt;&#xA;&lt;li&gt;go_old + dist -&amp;gt; asm, compile, link: 用老版本的Go和dist工具编译出bootstrap工具，asm用于汇编源码中的.s文件，输出.o对象文件；compile用于编译源码中的.go文件，输出归档打包后的.a文件；link用于链接二进制文件。这里还要依赖外部的pack程序，负责归档打包编译的库。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;到这里，dist/asm/compile/link都是链接的老的runtime，所以其运行依赖于go_old。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;asm, compile, link -&amp;gt; go_bootstrap: 这里用新代码的asm/compile/link的逻辑编译出新的go二进制文件及其依赖的所有包，包括新的runtime。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;go_bootstrap install std cmd: 重新编译所有的标准库和二进制文件，替换之前编译的所有标准库和二进制工具(包括之前编译的dist,asm,link,compile等)，这样标准库和二进制工具依赖的都是新的代码编译生成的runtime，而且是用新的代码本身的编译链接逻辑。(这里go_bootstrap install会使用上一步的asm,compile,link工具实现编译链接，虽然其用的是go_old的runtime，但是这几个工具已经是新代码的编译链接逻辑)。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一句话总结，借用老的runtime编译新的代码逻辑(编译器、链接器、新的runtime)生成新代码的编译、链接工具，并用这些工具重新编译新代码和工具本身。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-具体实现&#34;&gt;2. 具体实现&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生成dist&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// make.bash&#xA;# 编译cmd/dist，需要在host os和host arch下编译(dist需要在本地机器运行)，因此这里把环境变量清掉了&#xA;# 注意在bash中，单行的环境变量只影响后面的命令，不会覆盖外部环境变量!!!&#xA;GOROOT=&amp;#34;$GOROOT_BOOTSTRAP&amp;#34; GOOS=&amp;#34;&amp;#34; GOARCH=&amp;#34;&amp;#34; &amp;#34;$GOROOT_BOOTSTRAP/bin/go&amp;#34; build -o cmd/dist/dist ./cmd/dist&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;生成bootstrap二进制文件和库&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// make.bash&#xA;# 设置环境变量&#xA;eval $(./cmd/dist/dist env -p || echo FAIL=true)&#xA;&#xA;# 编译cmd/compile, cmd/asm, cmd/link, cmd/go bootstrap工具，注意外部传进来的GOOS和GOARCH目标平台的环境变量&#xA;# 这里可提供GOARCH和GOOS环境变量交叉编译&#xA;./cmd/dist/dist bootstrap $buildall $GO_DISTFLAGS -v # builds go_bootstrap&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;重新生成当前平台的go&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// make.bash&#xA;// std, cmd, all在go里有特殊的含义，这里重新编译了所有标准库和默认工具的二进制程序&#xA;if [ &amp;#34;$GOHOSTARCH&amp;#34; != &amp;#34;$GOARCH&amp;#34; -o &amp;#34;$GOHOSTOS&amp;#34; != &amp;#34;$GOOS&amp;#34; ]; then&#xA;  echo &amp;#34;##### Building packages and commands for host, $GOHOSTOS/$GOHOSTARCH.&amp;#34;&#xA;  # 重置GOOS和GOARCH环境变量，不会影响外层的环境变量&#xA;  CC=$CC GOOS=$GOHOSTOS GOARCH=$GOHOSTARCH \&#xA;    &amp;#34;$GOTOOLDIR&amp;#34;/go_bootstrap install -gcflags &amp;#34;$GO_GCFLAGS&amp;#34; -ldflags &amp;#34;$GO_LDFLAGS&amp;#34; -v std cmd&#xA;  echo&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;生成目标平台的Go&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CC=$CC_FOR_TARGET &amp;#34;$GOTOOLDIR&amp;#34;/go_bootstrap install $GO_FLAGS -gcflags &amp;#34;$GO_GCFLAGS&amp;#34; -ldflags &amp;#34;$GO_LDFLAGS&amp;#34; -v std cmd&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;dist bootstrap逻辑&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// cmd/dist&#xA;dist的bootstrap逻辑不具体分析了，基本过程是先编译好asm, compile, link工具，然后用它们编译cmd/go及其依赖的runtime和标准库。中间主要是用compile编译.go文件、asm汇编.s文件和用link/pack链接归档打包目标文件的过程。&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;3-小问题&#34;&gt;3. 小问题&lt;/h2&gt;&#xA;&lt;p&gt;分析代码中遇到几个值得注意的小问题:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的context包实现分析</title>
      <link>https://feilengcui008.github.io/post/go%E7%9A%84context%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 24 Apr 2017 21:07:23 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/go%E7%9A%84context%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</guid>
      <description>&lt;p&gt;Go1.7引入了context包，并在之后版本的标准库中广泛使用，尤其是net/http包。context包实现了一种优雅的并发安全的链式或树状通知机制，并且带取消、超时、值传递的特性，其底层还是基于channel、goroutine和time.Timer。通常一段应用程序会涉及多个树状的处理逻辑，树的节点之间存在一定依赖关系，比如子节点依赖父节点的完成，如果父节点退出，则子节点需要立即退出，所以这种模型可以比较优雅地处理程序的多个逻辑部分，而context很好地实现了这个模型。对于请求响应的形式(比如http)尤其适合这种模型。下面分析下context包的具体实现。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;1-基本设计&#34;&gt;1. 基本设计&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;context的类型主要有emptyCtx(用于默认Context)、cancelCtx(带cancel的Context)、timerCtx(计时并带cancel的Context)、valueCtx(携带kv键值对)，多种类型可以以父子节点形式相互组合其功能形成新的Context。&lt;/li&gt;&#xA;&lt;li&gt;cancelCtx是最核心的，是WithCancel的底层实现，且可包含多个cancelCtx子节点，从而构成一棵树。&lt;/li&gt;&#xA;&lt;li&gt;emptyCtx目前有两个实例化的ctx: background和TODO，background作为整个运行时的默认ctx，而TODO主要用来临时填充未确定具体Context类型的ctx参数&lt;/li&gt;&#xA;&lt;li&gt;timerCtx借助cancelCtx实现，只是其cancel的调用可由time.Timer的事件回调触发，WithDeadline和WithTimeout的底层实现。&lt;/li&gt;&#xA;&lt;li&gt;cancelCtx的cancel有几种方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主动调用cancel&lt;/li&gt;&#xA;&lt;li&gt;其父ctx被cancel，触发子ctx的cancel&lt;/li&gt;&#xA;&lt;li&gt;time.Timer事件触发timerCtx的cancel回调&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;当一个ctx被cancel后，ctx内部的负责通知的channel被关闭，从而触发select此channel的goroutine获得通知，完成相应逻辑的处理&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-具体实现&#34;&gt;2. 具体实现&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Context接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Context interface {&#xA;  // 只用于timerCtx，即WithDeadline和WithTimeout&#xA;  Deadline() (deadline time.Time, ok bool)&#xA;  // 需要获取通知的goroutine可以select此chan，当此ctx被cancel时，会close此chan&#xA;  Done() &amp;lt;-chan struct{}&#xA;  // 错误信息&#xA;  Err() error&#xA;  // 只用于valueCtx&#xA;  Value(key interface{}) interface{}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;几种主要Context的实现&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// cancelCtx&#xA;type cancelCtx struct {&#xA;  Context&#xA;  mu       sync.Mutex            &#xA;  done     chan struct{}         &#xA;  // 主要用于存储子cancelCtx和timerCtx&#xA;  // 当此ctx被cancel时，会自动cancel其所有children中的ctx&#xA;  children map[canceler]struct{} &#xA;  err      error                 &#xA;}&#xA;// timeCtx&#xA;type timerCtx struct {&#xA;  cancelCtx&#xA;  // 借助计时器触发timeout事件&#xA;  timer *time.Timer&#xA;  deadline time.Time&#xA;}&#xA;// valueCtx &#xA;type valueCtx struct {&#xA;  Context&#xA;  key, val interface{}&#xA;}&#xA;&#xA;// cancel逻辑&#xA;func (c *cancelCtx) cancel(removeFromParent bool, err error) {&#xA;  /* ... */&#xA;  c.err = err&#xA;  // 如果在第一次调用Done之前就调用cancel，则done为nil&#xA;  if c.done == nil {&#xA;    c.done = closedchan&#xA;  } else {&#xA;    close(c.done)&#xA;  }&#xA;  for child := range c.children {&#xA;    // NOTE: acquiring the child&amp;#39;s lock while holding parent&amp;#39;s lock.&#xA;    // 不能将子ctx从当前移除，由于移除需要拿当前ctx的锁&#xA;    child.cancel(false, err)&#xA;  }&#xA;  // 直接置为nil让gc处理子ctx的回收?&#xA;  c.children = nil&#xA;  c.mu.Unlock()&#xA;&#xA;  // 把自己从parent里移除，注意这里需要拿parent的锁&#xA;  if removeFromParent {&#xA;    removeChild(c.Context, c)&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;外部接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Background&#xA;func Background() Context {&#xA;  // 直接返回默认的顶层ctx&#xA;  return background&#xA;}&#xA;&#xA;// WithCancel&#xA;func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {&#xA;  // 实例化cancelCtx&#xA;  c := newCancelCtx(parent)&#xA;  // 如果parent是cancelCtx类型，则注册到parent.children，否则启用&#xA;  // 新的goroutine专门负责此ctx的cancel，当parent被cancel后，自动&#xA;  // 回调child的cancel&#xA;  propagateCancel(parent, &amp;amp;c)&#xA;  return &amp;amp;c, func() { c.cancel(true, Canceled) }&#xA;}&#xA;&#xA;// WithDeadline&#xA;func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) {&#xA;  // 如果parent是deadline，且比当前早，则直接返回cancelCtx&#xA;  if cur, ok := parent.Deadline(); ok &amp;amp;&amp;amp; cur.Before(deadline) {&#xA;    return WithCancel(parent)&#xA;  }&#xA;  c := &amp;amp;timerCtx{&#xA;    cancelCtx: newCancelCtx(parent),&#xA;    deadline:  deadline,&#xA;  }&#xA;  propagateCancel(parent, c)&#xA;  d := time.Until(deadline)&#xA;  // 已经过了&#xA;  if d &amp;lt;= 0 {&#xA;    c.cancel(true, DeadlineExceeded) // deadline has already passed&#xA;    return c, func() { c.cancel(true, Canceled) }&#xA;  }&#xA;  c.mu.Lock()&#xA;  defer c.mu.Unlock()&#xA;  if c.err == nil {&#xA;    // time.Timer到时则自动回调cancel&#xA;    c.timer = time.AfterFunc(d, func() {&#xA;      c.cancel(true, DeadlineExceeded)&#xA;    })&#xA;  }&#xA;  return c, func() { c.cancel(true, Canceled) }&#xA;}&#xA;&#xA;// WithTimeout&#xA;func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {&#xA;  // 直接使用WithDeadline的实现即可&#xA;  return WithDeadline(parent, time.Now().Add(timeout))&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;3-简单例子&#34;&gt;3. 简单例子&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main&#xA;&#xA;import (&#xA;  &amp;#34;context&amp;#34;&#xA;  &amp;#34;fmt&amp;#34;&#xA;  &amp;#34;time&amp;#34;&#xA;)&#xA;&#xA;func OuterLogicWithContext(ctx context.Context, fn func(ctx context.Context) error) error {&#xA;  go fn(ctx)&#xA;  for {&#xA;    select {&#xA;    case &amp;lt;-ctx.Done():&#xA;      fmt.Println(&amp;#34;OuterLogicWithContext ended&amp;#34;)&#xA;      return ctx.Err()&#xA;    }&#xA;  }&#xA;}&#xA;&#xA;func InnerLogicWithContext(ctx context.Context) error {&#xA;Loop:&#xA;  for {&#xA;    select {&#xA;    case &amp;lt;-ctx.Done():&#xA;      break Loop&#xA;    }&#xA;  }&#xA;  fmt.Println(&amp;#34;InnerLogicWithContext ended&amp;#34;)&#xA;  return ctx.Err()&#xA;}&#xA;&#xA;func main() {&#xA;  ctx := context.Background()&#xA;  var cancel context.CancelFunc&#xA;  ctx, cancel = context.WithCancel(ctx)&#xA;  ctx, cancel = context.WithTimeout(ctx, time.Second)&#xA;  go OuterLogicWithContext(ctx, InnerLogicWithContext)&#xA;  time.Sleep(time.Second * 3)&#xA;  // has been canceled by timer&#xA;  cancel()&#xA;  fmt.Println(&amp;#34;main ended&amp;#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
