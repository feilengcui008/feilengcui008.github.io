<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on </title>
    <link>https://feilengcui008.github.io/categories/python/</link>
    <description>Recent content in Python on </description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 16 Oct 2016 17:46:43 +0800</lastBuildDate>
    <atom:link href="https://feilengcui008.github.io/categories/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python退出时hang住的问题</title>
      <link>https://feilengcui008.github.io/post/python%E9%80%80%E5%87%BA%E6%97%B6hang%E4%BD%8F%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 16 Oct 2016 17:46:43 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/python%E9%80%80%E5%87%BA%E6%97%B6hang%E4%BD%8F%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;p&gt;最近使用Python遇到两个非常不好定位的问题，表现都是Python主线程退出时hang住。最终定位出一个是subprocess模块使用不当的问题，另一个是threading.Timer线程的问题。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;subprocess模块使用不当的问题&#34;&gt;subprocess模块使用不当的问题&lt;/h4&gt;&#xA;&lt;p&gt;Python的subprocess比较强大，基本上能替换os.system、os.popen、commands.getstatusoutput的功能，但是在使用的过程中需要注意参数stdin/stdout/stderr使用subprocess.PIPE的情况，因为管道通常会有默认大小的缓冲区(Linux x86_64下实测是64K)，父进程如果不使用communicate消耗掉子进程管道写端(stdout/stderr)中的数据，直接进入wait等待子进程退出，此时子进程可能阻塞在了pipe的写上，从而导致父子进程都hang住，下面是测试代码。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# main.py&#xA;#!/usr/bin/env python&#xA;# encoding: utf-8&#xA;&#xA;import subprocess&#xA;import os&#xA;import tempfile&#xA;import sys&#xA;import traceback&#xA;import commands&#xA;&#xA;&#xA;# both parent and child process will hang &#xA;# if run.py stdout/stderr exceed 64K, since&#xA;# parent process is waiting child process exit&#xA;# but child process is blocked by writing pipe&#xA;def testSubprocessCallPipe():&#xA;    # call: just Popen().wait()&#xA;    p = subprocess.Popen([&amp;#34;python&amp;#34;, &amp;#34;run.py&amp;#34;], &#xA;        stdin=subprocess.PIPE, &#xA;        stdout=subprocess.PIPE, &#xA;        stderr=subprocess.PIPE)&#xA;    ret = p.wait()&#xA;    print ret&#xA;&#xA;&#xA;# will not hang since the parent process which&#xA;# call communicate will poll or thread to comsume&#xA;# the pipe buffer, so the child process can write&#xA;# all it&amp;#39;s data to stdout or stderr pipe and it will&#xA;# not be blocked.&#xA;def testSubprocessCommunicate():&#xA;    p = subprocess.Popen([&amp;#34;python&amp;#34;, &amp;#34;run.py&amp;#34;], &#xA;        stdin=subprocess.PIPE, &#xA;        stdout=subprocess.PIPE, &#xA;        stderr=subprocess.PIPE)&#xA;    print p.communicate()[0]&#xA;&#xA;&#xA;# will not hang since sys.stdout and sys.stderr &#xA;# don&amp;#39;t have 64K default buffer limitation, child&#xA;# process can write all it&amp;#39;s data to stdout or &#xA;# stderr fd and exit&#xA;def testSubprocessCallStdout():&#xA;    # call: just Popen().wait()&#xA;    p = subprocess.Popen([&amp;#34;python&amp;#34;, &amp;#34;run.py&amp;#34;], &#xA;        stdin=sys.stdin, &#xA;        stdout=sys.stdout, &#xA;        stderr=sys.stderr)&#xA;    ret = p.wait()&#xA;    print ret&#xA;&#xA;&#xA;# will not hang since file has no limitation of 64K&#xA;def testSubprocessCallFile():&#xA;    stdout = tempfile.mktemp()&#xA;    stderr = tempfile.mktemp()&#xA;    print &amp;#34;stdout file %s&amp;#34; % (stdout,), &amp;#34;stderr file %s&amp;#34; % (stderr,)&#xA;    stdout = open(stdout, &amp;#34;w&amp;#34;)&#xA;    stderr = open(stderr, &amp;#34;w&amp;#34;)&#xA;    p = subprocess.Popen([&amp;#34;python&amp;#34;, &amp;#34;run.py&amp;#34;], &#xA;        stdin=None, &#xA;        stdout=stdout, &#xA;        stderr=stderr)&#xA;    ret = p.wait()&#xA;    print ret&#xA;&#xA;&#xA;print os.getpid()&#xA;# not hang&#xA;print &amp;#34;use file&amp;#34;&#xA;testSubprocessCallFile()&#xA;# not hang&#xA;print &amp;#34;use sys.stdout and sys.stderr&amp;#34;&#xA;testSubprocessCallStdout()&#xA;# not hang&#xA;print &amp;#34;use pipe and communicate&amp;#34;&#xA;testSubprocessCommunicate()&#xA;# hang&#xA;print &amp;#34;use pipe and call directly&amp;#34;&#xA;testSubprocessCallPipe()&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# run.py&#xA;import os&#xA;&#xA;print os.getpid()&#xA;&#xA;string = &amp;#34;&amp;#34;&#xA;# &amp;gt; 64k will hang&#xA;for i in range(1024 * 64 - 4):&#xA;    string = string + &amp;#34;c&amp;#34;&#xA;# flush to my stdout which might &#xA;# be sys.stdout/pipe/fd...&#xA;print string&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外，在subprocess模块源码中还注释说明了另外一种由于fork -&amp;gt; 子进程gc -&amp;gt; exec导致的进程hang住，详细信息可以阅读subprocess模块源码。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
