<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on </title>
    <link>https://feilengcui008.github.io/tags/rust/</link>
    <description>Recent content in Rust on </description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Jun 2023 19:52:51 +0800</lastBuildDate>
    <atom:link href="https://feilengcui008.github.io/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust实践</title>
      <link>https://feilengcui008.github.io/post/rust%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 28 Jun 2023 19:52:51 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/rust%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h1 id=&#34;依赖关系引用计数arc与锁mutex&#34;&gt;依赖关系、引用、计数（Arc）与锁（Mutex）&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;功能模块的设计清晰，最终一定是DAG，即使出现循环依赖也可以通过抽取公共部分为第三模块来解除循环依&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Rust里类型初始化每个成员必须强制显示初始化，所以这种循环依赖其实写不出来，虽然也可以通过Option来绕过，但是不推荐这种做法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;引用是表达依赖关系的方式&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当一个模块只被某个模块唯一引用那么其实就是own的关系，这时在模块初始化时用move语义即可（即拥有所有权）&lt;/li&gt;&#xA;&lt;li&gt;当一个模块被多个模块引用时，会出现生命周期问题，即：被引用模块的生命周期需要大于等于引用它的所有模块的生命周期，否则容易出现use after free问题&lt;/li&gt;&#xA;&lt;li&gt;依赖关系不只是模块（struct）间，也可能是此struct方法成员启动的协程/线程间，每个协程/线程都有自己的生命周期，通过struct方法启动则说明对其有依赖，也就是此struct会被多方引用（即依赖）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;原子计数（Arc）是解决多引用生命周期问题很自然的工具，类似C++智能指针。Arc对象可以被clone，这样每个引用者就可以own此Arc的拷贝（注意own的是Arc拷贝的所有权，而不是持有引用），而通过此Arc的拷贝，间接持有了目标对象的引用，而Arc的原子计数可以保证目标对象的生命周期至少比其所有引用持有者长。&lt;/li&gt;&#xA;&lt;li&gt;当目标对象通过Arc被多方持有后，生命周期问题得以解决（不会出现use after free问题），但是多个引用者需要并发访问（读写）目标对象。显然，只有Arc原子引用计数是不够的（并且Rust的借用规则并不允许多个&amp;amp;mut），这里需要做到共享与互斥，也就需要Atomic/Mutex/RwLock来控制对通过Arc引用的目标对象的并发读写。（不要去管Send/Sync，定义很难理解&amp;quot;准确&amp;quot;）&#xA;以上，是Arc&amp;lt;Mutex&lt;!-- raw HTML omitted --&gt;&amp;gt;、Arc&amp;lt;RwLock&lt;!-- raw HTML omitted --&gt;&amp;gt;常见用法的由来。常见模式：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Handler -&amp;gt; TableManager -&amp;gt; ElectionInfo&#xA;Handler -&amp;gt; TabletManager -&amp;gt; ElectionInfo&#xA;&#xA;pub struct Handler {&#xA;    pub table_manager: Arc&amp;lt;TableManager&amp;gt;,  // 持有Arc副本&#xA;    pub tablet_manager: Arc&amp;lt;TabletManager&amp;gt;,&#xA;}&#xA;&#xA;pub struct TableManager {&#xA;    election_info: Arc&amp;lt;ElectionInfo&amp;gt;,&#xA;}&#xA;&#xA;pub struct TabletManager {&#xA;    election_info: Arc&amp;lt;ElectionInfo&amp;gt;,&#xA;    tablets: RwLock&amp;lt;TabletRouter&amp;gt;, // 并发读写&#xA;    id_allocator: AtomicU64, // 并发读写&#xA;}&#xA;&#xA;// 怎么用&#xA;let election_info = Arc::new(ElectionInfo::new());&#xA;let table_manager = Arc::new(TableManager::new(election_info.clone()))&#xA;let tablet_manager = Arc::new(TableManager::new(election_info.clone()))&#xA;let handler = Handler::new(table_manager.clone(), tablet_manager.clone())&#xA;tokio::spawn({&#xA;    election_info.xxx&#xA;})&#xA;tokio::spawn({&#xA;    table_manager.yyy&#xA;})&#xA;tokio::spawn({&#xA;    tablet_manager.zzz&#xA;})&#xA;tokio::spawn({&#xA;    handler.table_manager.yyy&#xA;})&#xA;tokio::spawn({&#xA;    handler.tablet_manager.id_allocator.load()&#xA;    let router = handler.tablet_manager.tablets.write().unwrap();&#xA;    router.ggg&#xA;    // router unlocked&#xA;})&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;错误处理&#34;&gt;错误处理&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;实现自定义Error的From并善用?;能极大降低不同层次错误转换的冗余代码，当然有时需要更丰富的错误信息时，可以手动构造错误。此外，出现错误时希望打印日志或者metrics等信息然后通过?;快速返回，可以使用map_err&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pub async fn init_table(&amp;amp;self, table: &amp;amp;Table) -&amp;gt; Result&amp;lt;(), TabletManagerError&amp;gt; {&#xA;    if self.partitions.read().unwrap().get(&amp;amp;table_name).is_some() {&#xA;       // 手动构造TabletManagerError，errmsg中注入更多信息&#xA;       return Err(TabletManagerError::new(&amp;amp;format!(&#xA;           &amp;#34;{}:table {table_name} partitions already exist, can not init again&amp;#34;,&#xA;           ManagerErrorKind::TableAlreadyExist,&#xA;       )));&#xA;    }&#xA;    ....&#xA;    // map_err打印错误信息&#xA;    let rw_replica_val = serde_json::to_string(&amp;amp;rw_replica_route_info).map_err(|err| {&#xA;        tracing::error!(&#xA;            &amp;#34;init tablet serialize rw replica data failed {err}, {table_name} {tablet_id}&amp;#34;&#xA;        );&#xA;        err&#xA;    })?; // ?;错误快速返回，并由于TabletManagerError实现了From，这里会自动转换json错误为TabletManagerError&#xA;    ....&#xA;}&#xA;&#xA;impl From&amp;lt;serde_json::Error&amp;gt; for TabletManagerError {&#xA;    fn from(e: serde_json::Error) -&amp;gt; Self {&#xA;        TabletManagerError::new(&amp;#34;SystemError:serde json error&amp;#34;)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;在不希望明确具体的错误类型时，可以使用anyhow::Result/anyhow::format_error!&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 返回Result&amp;lt;&amp;gt;类型&#xA;pub async fn on_leader_start(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {&#xA;    self.tablet_task_manager&#xA;        .on_leader_start()&#xA;        .await&#xA;        .map_err(|err| {&#xA;            // 构造anyhow::Error&#xA;            anyhow::format_err!(&amp;#34;call tablet task manager on leader start failed {err}&amp;#34;,)&#xA;    })&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;stdsync--tokiosync&#34;&gt;std::sync &amp;amp; tokio::sync&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;垮await或者会导致线程长时间阻塞（例如睡眠挂起），用tokio::sync::Mutex/RwLock/Channel&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pub struct SystemInfoManager&amp;lt;T: KvStore&amp;gt; {&#xA;    replica_epoch_allocator: tokio::sync::Mutex&amp;lt;IdAllocator&amp;lt;T&amp;gt;&amp;gt;,&#xA;}&#xA;&#xA;impl&amp;lt;T: KvStore&amp;gt; SystemInfoManager&amp;lt;T&amp;gt; {&#xA;    pub async fn alloc_replica_epoch(&amp;amp;self) -&amp;gt; Result&amp;lt;u64, SystemInfoManagerError&amp;gt; {&#xA;        // replica_epoch_allocator跨await，需要使用异步版本的Mutex，否则可能导致线程hang&#xA;        let mut id_allocator = self.replica_epoch_allocator.lock().await;&#xA;        let new_id = id_allocator.alloc_id().await.map_err(|err| {&#xA;            let err_msg = format!(&amp;#34;alloc replica epoch failed {err}&amp;#34;);&#xA;            tracing::error!(err_msg);&#xA;            SystemInfoManagerError::new(&amp;amp;err_msg)&#xA;        })?;&#xA;        Ok(new_id)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;不垮await且临界区较短，使用std::sync::Mutex/RwLock，性能更好&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;结构体方法中启动协程定时任务&#34;&gt;结构体方法中启动协程定时任务&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;参数Arc&lt;!-- raw HTML omitted --&gt;，原因在于tokio::spawn的协程需要共享结构体的所有权，并对其进行读写访问&lt;/li&gt;&#xA;&lt;li&gt;tokio::select!，类似go中的select {}&lt;/li&gt;&#xA;&lt;li&gt;tokio_util::sync::CancellationToken&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;impl TabletReplicaController {&#xA;    pub fn run(self: Arc&amp;lt;Self&amp;gt;) {&#xA;        lust::spawn({&#xA;            async move {&#xA;                let cloned_token = self.base.cancel_token.clone();&#xA;                let mut tick_count = 0;&#xA;                loop {&#xA;                    let interval =&#xA;                        Duration::from_secs(get_config().tablet_replica_reconcile_interval_sec);&#xA;                    let enabled = get_config().enable_tablet_replica_reconcile_controller;&#xA;                    tokio::select! {&#xA;                        _ = cloned_token.cancelled() =&amp;gt; {&#xA;                            tracing::info!(&amp;#34;tablet replica reconcile controller exit on stop signal&amp;#34;);&#xA;                            return;&#xA;                        }&#xA;                        _ = tokio::time::sleep(interval) =&amp;gt; {&#xA;                            tick_count += 1;&#xA;                            if !self.base.election_info.is_leader() {&#xA;                                tracing::info!(&amp;#34;tablet replica reconcile controller not on leader, just skip&amp;#34;);&#xA;                                continue;&#xA;                            }&#xA;                            if !enabled {&#xA;                                tracing::info!(&amp;#34;tablet replica reconcile controller not enabled, just skip&amp;#34;);&#xA;                                continue;&#xA;                            }&#xA;                            if let Err(err) = self.do_tablet_replica_reconcile().await {&#xA;                                metrics(metric::defs::TABLET_REPLICA_CONTROLLER_RECONCILE_FAIL_COUNT).emit(tags![], 1);&#xA;                                tracing::error!(&amp;#34;do tablet replica reconcile failed {err}, tick {tick_count}&amp;#34;);&#xA;                                continue;&#xA;                            }&#xA;                            metrics(metric::defs::TABLET_REPLICA_CONTROLLER_RECONCILE_SUCCEED_COUNT).emit(tags![], 1);&#xA;                            tracing::debug!(&amp;#34;do tablet replica reconcile success, tick {tick_count}&amp;#34;);&#xA;                        }&#xA;                    }&#xA;                }&#xA;            }&#xA;        });&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;send--sync&#34;&gt;Send &amp;amp; Sync&lt;/h1&gt;&#xA;&lt;p&gt;按Rust的官方定义：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
