<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Paxos on </title>
    <link>https://feilengcui008.github.io/tags/paxos/</link>
    <description>Recent content in Paxos on </description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 08 Mar 2016 19:05:46 +0800</lastBuildDate>
    <atom:link href="https://feilengcui008.github.io/tags/paxos/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分布式一致性协议(一)</title>
      <link>https://feilengcui008.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-%E4%B8%80/</link>
      <pubDate>Tue, 08 Mar 2016 19:05:46 +0800</pubDate>
      <guid>https://feilengcui008.github.io/post/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE-%E4%B8%80/</guid>
      <description>&lt;p&gt;这一篇文章主要介绍一下分布式共识、分布式容错一致性协议的背景以及Paxos算法。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1-分布式系统基本概念&#34;&gt;1. 分布式系统基本概念&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;分布式系统的基本特点&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;部分故障&#xA;&lt;ul&gt;&#xA;&lt;li&gt;容错&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;没有全局时钟&#xA;&lt;ul&gt;&#xA;&lt;li&gt;事件定序 : 原子时钟，Lamport Clock，Vector Clock等&lt;/li&gt;&#xA;&lt;li&gt;副本一致性问题 : 通常为了保证容错，需要使用多个副本，副本之间的复制需要保证强一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;通信延时影响性能和扩展性&#xA;&lt;ul&gt;&#xA;&lt;li&gt;保证系统正确性下较少消息传递，减少共享状态，使用缓存等等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;系统模型&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步和异步&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步&lt;/li&gt;&#xA;&lt;li&gt;异步(执行时间和消息传递时间没有上限)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;网络模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可靠&lt;/li&gt;&#xA;&lt;li&gt;消息丢失，重复传递，消息乱序&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;故障模型&#xA;&lt;ul&gt;&#xA;&lt;li&gt;crash-failure fault&lt;/li&gt;&#xA;&lt;li&gt;byzantine fault&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一致性&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;data-central&#xA;&lt;ul&gt;&#xA;&lt;li&gt;严格一致性(strict consistency)&lt;/li&gt;&#xA;&lt;li&gt;线性一致性(linear consistency)&lt;/li&gt;&#xA;&lt;li&gt;顺序一致性(sequential consistency)&lt;/li&gt;&#xA;&lt;li&gt;因果一致性(casual consistency)&lt;/li&gt;&#xA;&lt;li&gt;弱一致性(weak consistency)&lt;/li&gt;&#xA;&lt;li&gt;最终一致性(eventual consistency)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;client-central&#xA;&lt;ul&gt;&#xA;&lt;li&gt;单调读一致性(Monotonic Reads Consistency)&lt;/li&gt;&#xA;&lt;li&gt;单调写一致性(Monotonic Writes Consistency)&lt;/li&gt;&#xA;&lt;li&gt;读写一致性(Read Your Writes Consistency)&lt;/li&gt;&#xA;&lt;li&gt;写读一致性(Write Follows Read Consistency)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;其他&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2分布式共识问题及容错分布式一致性协议&#34;&gt;2.分布式共识问题及容错分布式一致性协议&lt;/h3&gt;&#xA;&lt;p&gt;导致对Paxos理解困难的一个原因是对分布式共识问题本身没有较好的理解。先举个简单例子，然后再说明其需要满足的safety和liveness条件。&lt;/p&gt;&#xA;&lt;p&gt;例子：多个人在食堂决定吃什么菜，不能事先商量好，每个人都可以同时提出一样菜，中间可能有些人临时去上厕所了，待会重新回来，要保证的是最终只有一种菜被接受，而且重新回来的人在需要的时候能够知道这次吃饭到底吃的是什么菜。这里需要注意的是：“同时”说明并发的，有些提议的值可能被覆盖的；“有人临时上厕所”说明需要容错，即在机器挂掉下的分布式一致；“重新回来”说明机器recover后能知道之前决议的结果；&lt;/p&gt;&#xA;&lt;p&gt;分布式共识问题通常需要满足Safety和Liveness的要求，具体来说就是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Safety&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;只有被提出的值才有可能通过决议&lt;/li&gt;&#xA;&lt;li&gt;最终只有一个值被接受&lt;/li&gt;&#xA;&lt;li&gt;一个参与者只有在决议达成之后才可能知道决议的值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Liveness&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最终能对某个值达成决议&lt;/li&gt;&#xA;&lt;li&gt;如果有一个值达成了决议，那么这个值能最终被参与者学习到&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于Liveness的问题想多说点，在FLP定理中讨论的模型是完全异步，crash-failure fault但网络可靠这种假设比较严格的模型，并证明了在此系统模型下不存在完整的分布式一致性算法能解决分布式共识问题(注意是完整，如果我们放弃一些Safety或者Liveness的要求，比如保证严格的Safety而使用随机化等方法保证一定概率的Liveness，这样的算法是能实现的，而这也是Paxos一类算法的取舍，毕竟放弃了Safety没太大意义了），而通常像Paxos和类Paxos算法讨论的模型比FLP中的模型更松：完全异步，网络不可靠，crash-failure fault甚至byzantine fault，所以Paxos类算法本质上也没办法完美解决Liveness的问题，Lamport的原始论文中只提到选主(选出distinguished proposer)来解决这个问题，但是至于选主本身的Liveness和容错问题并没有详细讨论，这在后面选主相关部分还会涉及到。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
